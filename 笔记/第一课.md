[TOC]



# 一、Java 概述

## 1.1 Java 的特点

- Java语言是面向对象的 (oop)
- Java语言是健壮的。Java的强类型机制. 异常处理. 垃圾的自动收集等是Java程序健壮性的重要保证
- Java语言是跨平台性的。【即:一个编译好的.  class 文件可以在多个系统下运行，这种特性称为跨平台】
- Java语言时解释型的【了解】

***	区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行,编译性语言,编译后的代码，可以直接被机器执行, C/C++*** 

## 1.2 Java 开发快速入门

### 1.2.1 什么是运行

- 有了可执行的 java 程序 (Hello.class 字节码文件)
- 通过运行工具 java.exe 对字节码文件进行执行,本质就是 .  class 装载到 jvm 机执行 java 程序开发注意事项
- 对修改后的 Hello.java 源文件需要重新编译，生成新的 class 文件后,再进行执行,才能生效。
- java 为源文件 .class 为字节码文件

​	**举例**

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("hello,world~");
    }
}
```
  - `public class Hello`表示 Hello 是一个类，是一个 public 公有的类
  - `Hello{}`表示一个类的开始和结束
  - `public static void main(String[] args)` 表示一个主方法,即我们程序的入口
  - `main(){}` 表示方法的开始和结束
  - `System.out.println( "hello, world~"); `表示输出 "hello,world~" 到屏幕
  - `;` 表示语句结束


## 1.3 Java 开发注意事项和细节说明
- Java 源文件以 .java 为扩展名。源文件的基本组成部分是类(class)，如本类中的Hello
  类。

- Java 应用程序的执行入口是 main() 方法。它有固定的书写格式 :

  `public static void main(String[] args){...}`

- Java 语言严格区分大小写。

- .Java 方法由一条条语句构成，每个语句以 “;” 结束。

- 大括号都是成对出现的,缺一不可。【习惯，先写再写代码】

- 一个源文件中最多只能有一个 public 类。其它类的个数不限。[【演示】

- 如果源文件包含一个 public 类,则文件名必须按该类名命名!

- 一个源文件中最多只能有一个 public 类。其它类的个数不限,也可以将 main 方法写在非 public 类中，然后指定运行非 public 类，这样入口方法就是非 public 的 main 方法

## 1.4 Java 常用的转义字符

- `\t` : 一个制表位，实现对齐的功能
- `\n` : 换行符
- `\\`: 一个 \
- `\"` : 一个 "
- `\'` : 一个 '
- `\r` : 一个回车 `System.out.println("韩顺平教育\r北京")`

***控制台按 Tab 键可以实现快速补齐***

## 1.5 注释 -  [Comment01.java](/home/zhang/Java/代码/Comment01.java)

### 	1.5.1 介绍
​	用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性） 注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。【举例】

### 	1.5.2 Java 中的注释类型

- 单行注释
  格式：`// 注释文字`

- 多行注释

  格式：`/*注释文字*/`

- 文档注释
  - 被注释的文字，不会被 VM（ java 虚拟机 ）解释执行
  - ***多行注释里面不允许有多行注释嵌套***

## 1.6 文档注释

​	注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明一般写在类



## 1.7 Java 代码规范

- 类、方法的注释，要以 javadoc 的方式来写。
- 非 Java Doc 的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等
- 使用 tab 操作，实现缩进，默认整体向右边移动，时候用`shift + tab`整体向左移
- 运算符和 = 两边习惯性各加一个空格。比如：`2 + 4 * 5 + 345 - 89`
- 源文件使用` utf-8` 编码
- 行宽度不要超过 `80`字符
- 代码编写次行风格和行尾风格

## 1.8 DOS 命令（了解）
### 1.8.1 DOS 介绍

​	Dos : Disk Operating System 磁盘操作系统，简单说一下 windows 的目录结构。

### 1.8.2 相关的知识补充

**相对路径：从当前目录开始定位，形成的一个路径**
**绝对路径：从顶级目录d,开始定位，形成的路径常用的 dos 命令**

- 查看当前目录是有什么
  案例演示：`dir `

- 查看指定目录下有什么 

  案例演示：`dir d:\abc2\test200`

- 切换到其他盘下：盘符号 cd
  案例演示：切换到 c 盘 `cd /D C:`

- 切换到当前盘的其他目录下（使用相对路径和绝对路径演示）
  案例演示：`cd d:\abc2\test200cd..abc2\test200`

- 切换到上一级
  案例演示：`cd..`

- 切换根目录

  案例演示：`cd \`

# 二、变量

## 2.1 变量的基本使用 

### 2.1.1 变量使用注意事项 - [VarDetails.java](代码/VarDetails.java)

- 变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同，比如：int 4 个字节，double 就是 8 个字节，先有基本印象，后面说字节】
- 该区域有自己 的名称【变量名】和类型【数据类型】
- 变量必须先声 明，后使用，即有顺序
- 该区域的数据 / 值可以在同一类型范围内不断变化
- 变量在同一个作用域内不能重名
- `变量 = 变量名 + 值 + 数据类型`，这一点请大家注意。变量三要素。

### 2.1.2 程序中 + 号的使用

- 当左右两边都是数值型时，则做加法运算

- 当左右两边有一方为字符串，则做拼接运算
- 运算顺序，是从左到右的

# 三、数据类型

​	每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间字节）。

- .java 数据类型分为两大类型本数据类型，引用类生

- 基本数据类型有 8 中数值型

  - 数值型 

    - 整数类型，存放整数 ：Java 的整数类型就是用于存放整数值的，比如12,30,3456等等

      byte [1] , short [2], int [4] , long [8]

    - 浮点（小数）类型 ：float [4] , double [8]

  - 字符型 char ：存放单个字符 'a'

  - 布尔型 boolean ：存放 true，false

- 引用类型

  - 类 ：class
  - 接口 ：interface
  - 数组 ：[]

## 3.1 整型类型 - [IntDetails.java](/home/zhang/Java/代码/IntDetails.java)

| 类型           | 占用存储空间 | 范围                                      |
| -------------- | ------------ | ----------------------------------------- |
| byte [字节]    | 1字节        | -128～127                                 |
| short [短整型] | 2字节        | -(2^15) ~2^15-1  /  32768 - 32767         |
| int [整型]     | 4字节        | -2^31~2^31-1   /   -2147483648-2147483647 |
| long [长整型]  | 8字节        | -2^63～2^63-1                             |

- Java 各整数类型有固定的范围和字段长度，不受具体 OS 影响以保证 Java 程序的可移植性

- Java 的整型常量（具体值）默认为 int 型，声明 long 型常量须后加 ' l '或 ' L '

- Java 程序中变量常声明为 int 型，除非不足以表示大数，才使用 long

- bit : 计算机中的最小存储单位。byte : 计算机中基本存储单元,1 byte = 8 bit

## 3.2 浮点类型 - [FloatDetails.java](/home/zhang/Java/代码/FloatDetails.java)

**Java 的浮点类型可以表示一个小数，比如 123.4，7.8，0.12等等**

- 与整数类型类似，Java 浮点类型也有固定的范围和字段长度，不受具体 OS 的影响。【 float 4 个字节 double 是 8个字节 】

- Java 的浮点型常量默认为 double 型，声明 float 型常量，须后加 ' f '或 ' F '

- 浮点型常量有两种表示形式

  十进制数形式：如：`5.12`    `512.0f`    `.512` ( 必须有小数点 )

  科学计数法形式:如：5.12e2 [ 5.12 * 10 的 2 次方 ]    `5.12E-2` [ 5.12 / 10 的 2 次方 ]

- 通常情况下，应该使用 double 型，因为它比 float 型更精确。【举例说明】

  `double num9 = 2.1234567851;`

  `float num10 = 2.1234567851F;`

1. 浮点数使用陷阱: 2.7 和 8.1 / 3 比较

   ```java
   double num11 = 2.7;
   double num12 = 8.1 / 3; // 2.7
   System.out.println(num11); // 2.7
   System.out.println(num12); // 接近 2.7 的一个小数，而不是 2.7
   ```

   得到一个重要的使用点：当我们对运算结果是小数的进行相等判断是，要小心。应该是以两个数的差值的绝对值，在某个精度范围类判断。

   ```java
   // 正确的写法
   if (Math.abs(num11 - num12) < 0.00001) {
       System.out.println("差值非常小，到我的规定精度，认为相等.··");
   }
   ```

## 3.3 Java API文档

- API ( Application Programming Interface，用程序编程接口 ) 是 Java 提供的基本编程接口( Java 提供的类还有相关的方法) - [中文在线文档](https://www.matools.com )

- Java 语言提供了大量的基础类，因此 Oracle 公司也为这些基础类提供了相应的 API 文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法
- Java 类的组织形式 - [图](Java类组织形式.png)

## 3.4 字符类型 (char) - [CharDetails.java](../代码/CharDetails.java)

### 3.4.1 字符类型使用细节

- 字符常量是用单引号(·')括起来的单个字符。例如：`char c1 = 'a';    char c2 = '中';    char c3 = '9';`
- Java 中还允许使用转义字符 ' \  '来将其后的字符转变为特殊字符型常量。例如：`char c3 = '\n';    // '\n'表换行符`
- 在 java 中，char 的本质是一个整数，在输出时，是
- [unicode 码对应的字符](http://tool.chinaz.com/Tools/Unicode.aspx)
- 可以直接给 char 赋一个整数，然后输出时，会按照对应的 unicode 字符输出 [97]
- char 类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码

## 3.5 布尔类型：boolean - [Boolean01.java](../代码/Boolean01.java)

- 不可以 0 或非 0 的整数替代 `false` 和 `true` ，这点和 C 语言不同

## 3.6 基本数据类型转换

### 3.6.1 自动类型转换 - [AutoConvertDetail.java](../代码/AutoConvertDetail.java)

​	**当 Java 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型**
**这个就是自勋类型转换。**

- 数据类型按精度（容量）大小排序为（背，规则）

  ![image-20220331184816846](C:\Users\a1097\AppData\Roaming\Typora\typora-user-images\image-20220331184816846.png)

- 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。

- 当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时就会报错，反之就会进行自动类型转换。
-  ( byte,short ) 和 char 之间不会相互自动转换
- byte,short,char 他们三者可以计算，在计算时首先转换为 int 类型
- boolean 不参与转换
-  自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

### 3.6.2 强制类型转换

**自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要**
**加上强制转换符(，但可能造成精度降低或溢出格外要注意。**

- 当进行数据的大小从大 —> 小，就需要使用到强制转换
- 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
-  char 类型可以保存 int 的常量值，但不能保存 int 的变量值，需要强转 

```java
判断是否能够通过编译：
1.short s = 12; // ok
s = s - 9; // 错误int -> short
    
2.byte b = 10; // ok
b = b + 11; // 错误 int -> byte
b = ( byte )( b + 11 ); // 正确，使用强转
    
3.char c = 'a'; // ok
int i = 16; // ok
float d .314F; // ok
double result = c + i + d; // ok float -> double

4.byte b = 16; // ok
short s = 14;// ok
short t = s + b; // 错误 int -> short
```

# 四、运算符

## 4.1 算术运算符 - [ArithmeticOperator.java](../代码/chapter04/ArithmeticOperator.java)

-  在 % 的本质看一个公式`a % b = a - a / b * b`

## 4.2 关系运算符 - [RelationalOperator.java](../代码/chapter04/RelationalOperator.java)

- 关系运算符的结果都是 boolean 型，也就是要么是 `true` ,要么是 `false`
- 关系表达式经常用在结构的条件中或循环结构的条件中

## 4.3 逻辑运算符 - [LogiclOperator01.java](../代码/chapter04/LogiclOperator01.java)

**用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值**

- ***短路与 &&：如果第一个条件为 `false`，则第二个条件不会判断，最终结果为 `false`***

- **短路或 ||：如果第一个条件为 `true`，则第二个条件不会判断，最终结果为 `true`。效率高**

- 取反 ！

- 逻辑与 &

- 逻辑或 |
- **逻辑异或 ^：当 a 和 b 不同时，则结果为 `true`,否则为 `false`**

## 4.4 赋值运算符 - [AssignOperator.java](../代码/chapter04/AssignOperator.java)

- 复合赋值运算符会进行类型转换

```java
byte b = 3;
b += 2; // b = (byte) (b + 2);
```

## 4.5 二元运算符 - [TernaryOperator.java](../代码/chapter04/TernaryOperator.java)

`条件表达式 ? 表达式 1 ：表达式 2 ;`

- 如果条件表达式为 `true`，运算后的结果是表达式 1；
- 如果条件表达式为 `false`，运算后的结果是表达式 2。

## 4.6 运算符优先级

- () , {}等
- 单目运行
- ++ 算术运算符
- 位移运算符
- 比较运算符
- 逻辑运算符
- 三元运算符
- 赋值运算符

## 4.7 标识符的命名规则和规范

### 4.7.1 标识符概念

- Java对各种变量、方法和类等命名时使用的字符序列称为标识符
- 凡是自己可以起名字的地方都叫标识符 `int num1 = 90;`

### 4.7.2 标识符的命名规则（必须遵守）

- 由 26 个英文字母大小写，0 - 9，或 $ 组成
- 数字不可以开头。`int 3ab = 1; //错误`
- 不可以使用关键字和保留字，但能包含关键字和保留字。
- Java 中严格区分大小写，长度无限制。`int totalNum = 10; int n = 90;`
- 标识符不能包含空格。`int a b = 90;`

### 4.7.3 标识符命名规范（更加专业）

- 包名：多单词组成时所有字母都小写：`aaa.bbb.ccc // 比如com.hsp.crm`
- 类名、接口名：多单词组成时，所有单词的首字母大写：`XxxYyyZzz` 。比如：`TankShotGame`
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：`xxxYyyZzz`。比如：`tankShotGame`
- 常量名：所有字母都大写。多单词时每个单词用下划线连接：`XXX_YYY_ZZZ`。比如：定义一个所得税率 `TAX_RATE`
- 后面我们学习到类，包，接口，等时，我们的命名规范要这样遵守，更加详细的看文档。

## 4.8 关键字

### 4.8.1 关键字的定义和特点（不用背）

- **定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）**
- 特点：关键字中所有字母都为小写

![image-20220405135804111](C:\Users\a1097\AppData\Roaming\Typora\typora-user-images\image-20220405135804111.png)

## 4.9 保留字

- **Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。**

- 自己命名标识符时要避免使用这些保留字 `onValue、cast、future、generic、inner、operator、outer、rest、var、goto、const`

## 4.10 键盘输入语句

**在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。** 

Input.java ，需要一个扫描器（对象），就是 Scanner。

```java
import java.util.Scanner; // 表示把 java.util 下的 Scanner 类导入
public class Input {
    public static void main(String[] args) {
        // 演示接受用户的输入
        // 步骤
        // Scanner类表示简单文本扫描器，在java.util包
        // 1.引入/导入Scanner类所在的包
        // 2.创建Scanner对象
        Scanner myScanner = new Scanner(System.in);
        // 3.接受用户的输入；使用相关的方法
        System.out.println("请输入文字");
        String name = myScanner.next()
    }
}
```

## 4.11 进制

对于整数，有四种表示方式：

- 二进制：0 , 1，满 2 进 1 以 0b 或 0B 开头。
- 十进制：0-9，满 10 进 1 。
- 八进制：0-7，满 8 进 1 以数字 0 开头表示。
- 十六进制：0-9及 (10) - F (15) , 满 16 进 1 以 0x 或 0X 开头表示。此处的A -F不区分大小写。

## 4.12 反码、补码、移码

- 二进制的最高位是符号位：0 表示正数，1 表示负数【老韩口诀：0->0 1-> -】
- **正数**的原码，反码，补码都一样【三码合一】
- **负数**的反码=它的原码符号位不变，其它位取反（0 -> 1 ，1 -> 0）
- **负数**的补码=它的反码+1，负数的反码 = 负数的补码 -1
- 0 的反码，补码都是 0
- Java 没有无符号数，换言之，Java 中的数都是有符号的
- 在计算机运算的时候，都是以补码的方式来运算的
- 当我们看运算结果的时候，要看他的原码【重点】

## 4.13 位运算符 - [BitOperator01.java](../代码/chapter05/BitOperator01.java)

Java 中有 7 个位运算（&、|、^、~、>>、<< 和 >>> ）

- 按位与 & ：两位全为1，结果为 1，否则为 0
- 按位或 | ：两位有一个为 1，结果为 1，否则为 0
- 按位异或 Λ ：两位一个为 0 ，一个为 1 ，结果为 1 ，否则为 0
- 按位取反 ~ ：0 -> 1 ，1 -> 0

- 算术右移 >> ：低位溢出，符号位不变，并用符号位补溢出的高位
- 算术左移 << ：符号位不变，低位补 0

- 逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补 0 
- 特别说明：没有 <<< 符号

# 五、控制结构

## 5.1 顺序控制

程序从上到下逐行地执行，中间没有任何判断和跳转。

## 5.2 分支控制

### 5.2.1 分支控制 if - else

- 单分支 - [If01.java](../代码/chapter05/If01.java)
- 双分支 - [If02.java](../代码/chapter05/If02.java)
- 多分支 - [If03.java](../代码/chapter05/If03.java)
- 嵌套分支：嵌套最好不要超过三层 - [NestedIf.java](../代码/chapter05/NestedIf.java)
- switch 分支结构 - [Swatch01.java](../代码/chapter05/Swatch01.java)

## 5.3 循环控制

### 5.3.1 for 循环控制

```java
for(循环变量初始化;循环条件;循环变量迭代){
	循环体（语句）;
}
```

- `for (;;) {} // 死循环`

- for 循环执行顺序：

  ```java
  for(表达式1；表达式2；表达式3){
  	循环体
  }
  执行过程：
  java
  1、执行for后表达式1。
  
  2、执行表达式2，若表达式2的值为真（或非0），则执行for内循环体，然后执行。
  
  3、否则，则循环结束，执行（5）（3）执行表达式3。
  
  4、返回继续执行（2）（5）循环结束，执行for语句的循环体下面的语句。
  ```

### 5.3.2 while 循环制

```java
while(循形条件){
	循环体（语句）;
	循环变量迭代;
}	
```

- 循环条件是返回一个布尔值的表达式
- while 循环是先判断再执行语句

### 5.3.3 do..while循舔控制

```java
循环变量初始化;
do{
	循环体（语句）;
	循环变量迭代：
}while(循环条件);
```

### 5.3.4 多重循环控制（难点！重点！）

- 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do..while 均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层，否则，代码的可读性很差】。
- 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环【听不懂，走案例】。
- 设外层循环次数为 m 次， 内层为 n 次，则内层循环体实际上需要执行 m*n 次。

例 - [Stars.java](../代码/chapter05/Stars.java)

## 5.4 跳转控制语句

### 5.4.1 break：退出循环 

```java
{
	...
	break;
	...
}
```

### 5.4.2 continue：退出本次循环

### 5.4.3 return：退出所在方法

- 若 return 在 main 方法中，退出程序

# 六、数组

**数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。**

## 6.1 数组的使用

### 6.1.1 数组定义

`数据类型数组名 [] = new 数据类型[大小]`

### 6.1.2 数组使用

- 动态初始化 1：

```java
// 数据类型数组名 [] = new 数据类型[大小]
int a[] = new int[5];// 创建了一个数组，名字 a ,存放 5 个 int
```

- 动态初始化 2：

```java
// 先声明，在 new 分配空间
double scores[]; // 声明数组，这时 scores 为 null
scores = new double[5]; // 分配内存空间，可以存放数据
```

- 静态初始化：

  `int a[] = {2,5,6,7,8,9,90,34,56};`

### 6.1.3 数组使用注意事项和细节

- 数组是多个相同类型数据的组合，实现对这些数据的统一管理

- 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用

- 数组创建后，如果没有赋值有默认值

  `int = 0 , short = 0 , byte = 0 , long = 0 , float = 0.0 , double = 0.0 , char = \u0000 , boolean = false , String = null`

- 使用数组的步骤：1、声明数组并开辟空间；2、给数组各个元素赋值；3、使用数组

- 数组的下标是从 0 开始

- 数组下标必须在指定范围内使用，否则报：下标越界异常，比如

  `int[] arr = new int[5];  // 则有效下标为 0 - 4`

- 数组属引用类型，数组型数据是对象 ( object )

## 6.2 数组赋值机制 - [ArrayAssign.java](../代码/chapter06/ArrayAssign.java)

- 基本数据类型赋值，这个值就是具体的数据，而且相互不影响

  `int n1 = 2;int = n2 n1;`

- 数组在默认情况下是引用传递，赋的值是地址

## 6.3 数组拷贝 - [ArrayCopy.java](../代码/chapter06/ArrayCopy.java)

编写代码实现数组拷贝（内容复制）

```java
// 将int [] arr1 = {10,20,30}; // 拷贝到 arr2 数组
int[] arr1 = { 1, 2, 3 };
int[] arr2 = new int[arr1.length];
for (int i = 0; i < arr2.length; i++) 
arr2[i] = arr1[i];
```

## 6.4 数组反转 - [ArrayReverse.java](../代码/chapter06/ArrayReverse.java)

- 方法一：

```java
int[] arr = { 11, 22, 33, 44, 55, 66 };  // 定义数组
int temp = arr[0];
for (int i = 0; i < arr.length / 2; i++) {
    temp = arr[i];
    arr[i] = arr[arr.length - 1 - i];
    arr[arr.length - i - 1] = temp;
}
```

- 方法二：

```java
int[] arr = { 11, 22, 33, 44, 55, 66 }; // 定义数组
int[] arr2 = new int[arr.length]; // 存放逆置后的数组
for (int i = 0; i < arr.length; i++) {
    arr2[i] = arr[arr.length - 1 - i];
}
arr = arr2; // arr2 会被当做垃圾，销毁
```

## 6.5 数组添加 - [ArrayAdd.java](../代码/chapter06/ArrayAdd.java)

## 6.6 排序

### 6.6.1排序的分类

- **内部排序：**

  指将需要处理的所有数据都加载到内部存储器中进行排序。包括（ *交换式排序法*、*选择式排序法*、*插入式排序法* )

  - 冒泡排序 - [BubbleSore.java](../代码/chapter06/BubbleSore.java)

- **外部排序法：**

  数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法 )

## 6.7 查找

在 Java 中，我们常用的查找有两种：

- 顺序查找 - [SeqSearch.java](../代码/chapter06/SeqSearch.java)
- 二分查找【二分法，放在算法讲解】

## 6.8 多维数组 - 二维数组

### 6.8.1 二维数组的使用- [TwoDimensionArray01.java](../代码/chapter06/TwoDimensionArray01.java)

`arr[i]` 表示二维数组的第 i + 1 个元素比如 arr[0]：二维数组的第一个元素
`arr[i].length` 得到对应的每个一维数组的长度

- **使用方式1：动态初始化**

语法：`类型[][] 数组名 = new 类型 [大小][大小]`

比如：`int a [][] = new int[3][3]`

- **使用方式2：动态初始化**

先声明：`类型数组名[][];`

再定义（开辟空间）：`数组名 = new 类型 [大小][大小]`

赋值：有默认值，比如 int 类型的就是 0 

- **使用方式3：动态初始化**

先声明行：`int[][] yanghui = new int[10][]; // 定义数组`

在定义列：`yanghui[i] = new int[i + 1];`

- **使用方式4：静态初始化**

`定义类型数组名 = {{ 值1,值2...},{值1,值2...},{值1,值2...}}`

使用即可 [ 固定方式访问 ]

### 6.8.2 二维数组的遍历

[杨辉三角](../代码/chapter06/YangHui.java)

### 6.8.3 二维数组使用细节和注意事项

- 一维数组的声明方式有：

`int[] x` 或者 `int x[]`

- 二维数组的声明方式有：

`int[][] y`或者 `int [][] y` 或者 `int[] y[]`

- 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同， 也可以不相同。比如：`map [][]` 是一个二维数组 

`int map [][] = {{ 1,2 } , { 3,4,5 }}`

​	由 `map[0]` 是一个含有两个元素的一维数组，`map[1]` 是一个含有三个元素的维数组构成，我们也称为列数不等的二维数组。

# 七、面向对象编程

## 7.1  类与对象

 一个程序就是一个世界，有很多事物（ 对象 [ 属性 ，行为 ] ）

### 7.1.1 类与对象的关系[Object01.java](../代码/chapter07/Object01.java)

![image-20220418151618181](C:\Users\a1097\AppData\Roaming\Typora\typora-user-images\image-20220418151618181.png)

```java
class Cat {
    // 属性
    String name; // 名字
    int age; // 年龄
    String color; // 颜色
    double weight; // 体重
}
```

### 7.1.2 属性/成员变量 

- 从概念或叫法上看：`成员变量 = 属性 = field` （字段）（即成员变量是用来表示属性 的，授课中，统一叫属性）

  `Car(name,price,color)`

- 属性是类的一个组成部分，一般是基本数据类型，也可是引用类型（对象，数组） 比如我们前面定义猫类的 `int age` 就是属性

### 7.1.3 注意事项和细节说明 [PropertiesDetail.java ]()

- 属性的定义语法同变量，示例：`访问修饰符 属性类型 属性名;`

  *有四种访问修饰符：publice, protected, 默认, private*

- 属性的定义类型可以为任意类型，包含基本类型或引用类型

- 属性如果不赋值，有默认值，规则和数组一致。

### 7.1.4 如何创建对象 [Object02.java](../代码/chapter07/Object02.java)

- 先声明再创建 

```java
Cat cat; // 声明对象 cat

cat = new Cat(); // 创建 
```

- 直接创建

`Cat cat = new Cat();`

### 7.1.5 如何使用对象

`对像名.属性名;`

### 7.1.6 类和对象的内存分配机制（重要）

**Java内存的结构分析：** 

- 栈：一般存放基本数据类型（局部变量） 

- 堆：存放对象(Cat cat,数组等) 

- 方法区：常量池（常量，比如字符串），类加载信息 

```java
Person p1 = new Person();
p1.age = 10;
p1.name = "小明";
Person p2 = p1;// 把p1赋给了p2,让p2指向p1
System.out.printIn(p2.age);
```

![image-20220418202000712](C:\Users\a1097\AppData\Roaming\Typora\typora-user-images\image-20220418202000712.png)

## 7.2 成员方法 [Method01.java](../代码/chapter07/Method01.java)

某些情况下，我们要需要定义成员方法（简称方法）。比如人类：除了有一些属性外（年龄， 姓名），我们人类还有一些行为比如：可以说话、跑步，通过学习，还可以做算术题。这时就 要用成员方法才能完成。现在要求对Person类完善。

```java
public 返回数据类型方法名（形参列表）{//方法体
	语句;    
	return 返回值;
}
```

**返回数据类型：**

-  一个方法最多有一个返回值【可以返回数组】

  ```java
  public int[] getSumAndSub(int n1, int n2) {
      int[] resArr = new int[2];
      resArr[0] = n1 + n2;
      resArr[1] = n1 - n2;
      return resArr;
  }
  ```

- 返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）

- 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值；而且要求返回值类型必须和 return 的值类型一致 或兼容

- 如果方法是 void，则方法体中可以没有 return 语句，回或者只写 return; 

### 7.2.1 方法名：

- 遵循驼峰命名法，最好见名知义，表达出该功能的意思即可。比如得到两个数的和 getSum,开发中按照规范

**形参列表： [MethodDetail.java](../代码/chapter07/MethodDetail.java)**

- 一个方法可以有 0 个参数，也可以有多个参数，中间用逗号隔开，比如`getSum(int n1,int n2)` 

- 参数类型可以为任意类型，包含基本类型或引用类型，比如`printArr(int[][] map)` 

- 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数！【getSum】
-  方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参， 实参和形参的类型要一致或兼容、个数、顺序必须一致！

**方法体：**

- 里面写完成功能的具体的语句，可以为输入、输出、变量、运算分支、循环、方法调用，但里 面不能再定义方法！即：方法不能嵌套定义。

### 7.2.2 成员方法传参机制 [MethodParameter01.java](../Java/代码/chapter07/MethodParameter01.java)

***引用类型【数组、对象等】传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！***[MethodParameter02.java](../Java/代码/chapter07/MethodParameter02.java)

## 7.3 方法递归调用

**递归重要规则：**

- 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
- 方法的局部变量是独立的，不会相互影响，比如 n 变量
- 如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引 用类型的数据
- 递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError
- 当一个方法执行完毕，或者遇到 return,就会返回，遵守谁调用，就将结果返回给谯，同时当方法执行完毕或者返回时，该方法也就执行完毕。

------

[RecursionExercise01.java](../代码/chapter07/RecursionExercise01.java)

迷宫：[Maze.java](../代码/chapter07/Maze.java)【拓展：求最短路径 -> Floyd、Dijkstra】

*汉诺塔：[HanoiTower.java](../代码/chapter07/HanoiTower.java)【不懂】*

## 7.2 方法重载 [OverLoad01.java](../代码/chapter07/OverLoad01.java)

Java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！ 

比如：`System.out.println();` out 是 PrintStream 类型

### 7.2.1 重载的好处：

- 减轻了起名的麻烦

- 减轻了记名的麻烦

### 7.2.2 注意事项和使用细节：

- 方法名：必须相同
- 形参列表：必须不同 (形参**类型**或**个数**或**顺序**，至少有一样不同，参数名无要求)
- 返回类型：无要求

## 7.3 可变参数

***Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现。***

**基本语法:** 

```java
访问修饰符 返回类型 方法名（数据类型...形参名）{
}

public int sum(int... nums) {
    System.out.println("接受得参数个数 = " + nums.length);
    int res = 0;
    for (int i = 0; i < nums.length; i++)
        res += nums[i];
    return res;
}
```

### 7.3.1 注意事项和使用细节 ： [VarParameterDetail.java](../代码/chapter07/VarParameterDetail.java)

- 可变参数的实参可以为 `0 个或任意多个`
- 可变参数的实参可以为`数组`
- 可变参数的`本质就是数组`
- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证`可变参数在最后`
- 一个形参列表中只能出现一个可变参数

## 7.4 作用域

*在 Java 编程中，主要的变量就是属性（成员变量）和局部变量。我们说的局部变量一般是指在成员方法中定义的变量。* 

**Java 中作用域的分类：**

| 全局变量 | 也就是属性，作用域为整个类体                                 |
| :------: | :----------------------------------------------------------- |
| 局部变量 | 也就是除了属性之外的其他变量，作用域为定义它的代码块中！ 全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后 才能使用，因为没有默认值。 |

### 7.4.1 注意事项和细节使用：[VarScopeDetail.java](../代码/chapter07/VarScopeDetail.java)

- 属性和局部变量可以重名，访问时遵循就近原则。
- 在同一个作用域冲，比如在同一个成员方法中，两个局部变量，不能重名。
- 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡；局部变量生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。 即在一次方法调用过程中。

- 作用域范围不同

  全局变量：可以被本类使用，或其他类使用( 通过对象调用) 

  局部变量：只能在本类中对应的方法中使用 

- 修饰符不同
  - 全局变量/属性可以加修饰符
  - 局部变量不可以加修饰符

## 7.5 构造方法/构造器

构造方法又叫构造器 ( constructor ) ，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。

❗不创建对象，***仅初始化对象***

**基本语法：**

```java
[修饰符] 方法名 (形参列表) {
	方法体;
}

public conPerson(String pName, int pAge) {
    System.out.println("构造器被调用，完成对象属性初始化！");
    name = pName;
    age = pAge;
}
```

**老韩说明：**

- 构造器的修饰符可以默认，也可以是`public、protected、private`
- ❗构造器***没有返回值***
- 方法名和类名字必须一样
- 参数列表和成员方法一样的规则
- 构造器的调用由系统完成

### 7.5.1 注意事项和使用细节：[ConstructorDetail.java](../代码/chapter07/ConstructorDetail.java)

- 一个类可以定义多个不同的构造器，即构造器重载

  比如：我们可以再给 `Person 类 `定义一个构造器，用来创建对象的时候，只指定人名不需要指定年龄

- 构造器名和类名要相同

- 构造器没有返回值

- 构造器是完成对象的初始化，并不是创建对象

- 在创建对象时，系统自动的调用该类的构造方法

- 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器)，比如 `Dog(){}` 使用 `javap指令` 反编译看看

- 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下。即：`Person(){}`

### 7.5.2 对象创建的流程分析

```java
class Person { // Person
    int age = 90;
    String name;
    
    Person(String n,int a); // 构造器
    name = n; // 给属性赋值 
    age = a; // ..
}
Person p = new Person("小倩",20);
```

**流程分析（面试题）：**

- 1.加载 Person 类信息 ( Person.class ) ，只会加载一次

- 2.在堆中分配空间（地址）

- 3.完成对象初始化

  - 3.1 默认初始化 `age = 0 name = null`

  - 3.2 显式初始化 `age = 90 name = null`

  - 3.3 构造器的初始化 `age = 20 name = 小倩`

- 4.在对象在堆中的地址，返回给 p（p 是对象名，也可以理解成是对象的引用）

## 7.6 this 关键字 [ThisDetai.java](../代码/chapter07/ThisDetai.java)

简单的说，那个对象调用，this 就代耒那个对象。

- this 关键字可以用来访问本类的属性、方法、构造器
- this 用于区分当前类的属性和局部变量
- 访问成员方法的语法：`this.方法名(参数列表);`
- 访问构造器语法：`this(参数列表);`注意只能在构造器中使用（即只能在构造器中访问另外一个构造器)
- this不能在类定义的外部使用，**❗只能在类定义的方法中使用**
