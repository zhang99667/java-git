# 十二、异常

## 12.1 异常介绍

### 12.1.1 基本介绍

#### 概念

Java 语言中，将程序执行中发生的 **不正常情况** 称为 **异常**（开发过程中的语法错误和逻辑错误不是异常）

#### 执行过程中所发生的异常事件可分为两大类

1）`Error`（错误）：Java 虚拟机无法解决的严重问题	。如：JVM 系统内部错误、资源耗尽等严重情况。比如：`StackOverflowError` [栈溢出] 和 `OOM` (out of memory), Error 是 **严重错误**，程序 **会崩溃**。

2）`Exception`：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为 **两大类**：**运行时异常【程序运行时，发生的异常】** 和 **编译时异常【编译时，编译器检查出的异常】**。

#### 异常体系图一览

<img src=".\img\image-20220817180039733.png" alt="image-20220817180039733"  />

### 12.1.2 异常体系图的小结

1. 异常分为 **两大类**，**运行时异常** 和 **编译时异常**
2. 运行时异常，编译器 **不要求强制处置** 的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常 `java.lang.RuntimeException` 类 及它的 **子类** 都是 **运行时异常**
3. 对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的 **可读性** 和 **运行效率** 产生影响
4. **编译时异常** 是编译器要求 **必须处置** 的异常。

### 12.1.3 常见的运行时异常

#### 常见的运行时异常包括

- `NullPointerException`：空指针异常

  当应用程序试图在需要对象的地方使用时，抛出该异常。

- `ArithmeticException`：数学运算异常

  当出现异常的 **运算条件** 时，抛出比异常。例如，一个整数 “除以零” 时，抛出此类的一个实例。

- `ArrayIndexOutOfBoundsException`：数组下标越界异常

  用 **非法索引** 访问数组时抛出的异常。如果 **索引** 为 **负** 或 **大于等于** 数组大小，则该索引为非法索引

- `ClassCastException`：类型转换异常

- `NumberFormatException`：数字格式不正确异常

#### 常见的编译异常

- `SQLException`：操作数据库时，查询表可能发生异常
- `IOException`：操作文件时，发生的异常
- `FileNotFoundException`：当操作一个不存在的文件时，发生异常
- `ClassNotFoundException`：加载类，而该类不存在时，异常
- `EOFException`：操作文件，到文件末尾，发生异常
- `IllegalArguementException`：参数异常

## 12.2 `try-catch` 异常处理

### 12.2.1  基本介绍

#### try-catch

Java 提供 try 和 catch 块来处理异常。try 块用于包含 **可能出错** 的代码。catch块用于 **处理** try 块中发生的 **异常**。可以根据需要在程序中有多个数量的 `try-catch` 块。

#### 基本语法

```java
try {
	// 可疑代码
	// 将异常生成对应的异常对象，传递给catch块
catch(异常) {
	// 对异常的处理
}
    // 如果没有 finally 语法中也是可以通过的
```

### 12.2.2 异常处理注意事项

1. 如果异常发生了，则 **异常** 发生 **后面的代码不会执行**，直接进入到 catch 块

2. 如果异常没有发生，则 **顺序执行** try 的代码块，**不会进入** 到 catch

3. 如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等），则使用如下代码 - `finally { ... }`

4. 可以有 **多个** catch 语句，捕获不同的异常进行不同的业务处理，要求父类异常在后，子类异常在前，比如（`Exception` 在后，`NullPointerException` 在前，如果发生异常，只会匹配一个 catch。

5. 可以进行 `try-finally` 配合使用，这种用法相当于 **没有捕获** 异常，因此程序会直接崩掉。应用场景：无论是否发生异常，都会执行某个业务逻辑。

   ```java
   try {
   	// 代码
   }finally {
   	// 总是执行
   }
   ```

### 12.2.3 try-catch-finally 执行顺序小节

- 如果没有出现异常，则执行 try 块中所有语句，不执行 catch 块中语句，如果有 finally，最后还需要执行 finally 里面的语句

- 如果出现异常，则 try 块中异常发生后，try 块剩下的语句不再执行。将执行 catch 块中的语句，如果有finally，最后还需要执行 finally 里面的语句！

## 12.3 throws 异常处理

### 12.3.1 基本介绍

- 如果一个方法（中的语句执行时）可能生成某种异常，但是并 **不能确定** **如何处理** 这种异常，则此方法应 **显示地声明** 抛出异常，表明该方法将不对这些异常进行处理，而 **由该方法的调用者负责处理**。

- 在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

```java
    public void f1() throws FileNotFoundException,NullPointerException,ArithmeticException{
        // 创建了一个文件流对象
        // 1. 这里的异常是一个 FileNotFoundException 编译异常
        // 2. 使用前面的 try-catch-finally
        // 3. 使用 throws，抛出异常.让调用 f1 方法的调用者（方法）处理
        // 4. throws 后面的异常类型可以是方法中产生的异常类型，也可以是他的父类
        // 5. throws 关键字后也可以是 异常列表，即抛出多个异常
        FileInputStream fileInputStream = new FileInputStream("D://a.txt");
    }
```

### 12.3.2 注意事项和使用细节

- 对于 **编译异常**，程序中 **必须处理**，比如 `try-catch` 或者 `throws`
- 对于 **运行时异常**，程序中如果没有处理，**默认** 就是 `throws` 的方式处理
- 在 `throws` 过程中，如果有方法 `try-catch` 就相当于处理异常，就可以不必 `throws`【二选一】

## 12.4 自定义异常

### 12.4.1 基本概念

​	当程序中出现了某些 “错误”，但该错误信息并没有在 Throwable 子类中描述处理，这个时候可 **以自己设计异常类**，**用于描述该错误信息**。

#### 自定义异常的步骤

- 定义类：自定义异常类名（程序员自己写）继承 `Exception` 或 `RuntimeException`
- 如果继承 `Exception`，属于 **编译异常**
- 如果继承 `RuntimeException`，属于 **运行异常**（一般来说，继承 `RuntimeException` ）

```java
package Exception_.CustomException_;

import java.util.Scanner;

/*
 * 当我们接收 Person 对象年龄时，要求范围在 18-120 之间，否则抛出一个
 * 自定义异常（要求继承 RuntimeException ),并给出提示信息。
 * */
public class CustomException {
    public static void main(String[] args) {
        System.out.println("输入年龄，范围 18-120");
        int age = new Scanner(System.in).nextInt();
        if (!(age >= 18 && age <= 120)) {
            // 可以通过构造器设置信息
            throw new AgeException("年龄范围有误"); // 抛出自定义异常
        }
        System.out.println("年龄范围正常");
    }
}

// 自定义异常
// 1. 一般情况下，自定义异常继承 RuntimeException
// 2. 即把自定义异常做成 运行时异常
// 3. 即比较方便

class AgeException extends RuntimeException {
    public AgeException(String message) { // 构造器
        super(message);
    }
}
```

## 12.5 throw 和 throws 的区别

![image-20220818142314494](.\img\image-20220818142314494.png)

# 十三、八大 `wrapper`类

## 13.1 包装类 (wrapper) 的分类

1. 针对 **八种** 基本数据类型的引用类型 —— **包装类**
2. 有了类的特点，就可以调用类中的方法。

![image-20220818163958805](.\img\image-20220818163958805.png)

## 13.2 包装类和基本数据的转换

演示包装类和基本数据类型的相互转换，这里以 int 和 Integer 演示。

1) jdk5 前的手动装箱和拆箱方式，装箱：`基本类型 -> 包装类型`，反之，拆箱
2) jdk5 以后（含 jdk5）的 **自动** 装箱和拆箱方式
3) 自动装箱底层 **调用** 的是 `valueOf` 方法，比如 `Integer.valueOf()`

## 13.3 Integer 类和 Character 类的常用方法

Integer 类和 Character 有些常用的方法，我们一起来使用一下：

```java
System.out.println(Integer.MIN_VALUE); // 返回最小值
System.out.println(Integer.MAX_VALUE);// 返回最大值
System.out.println(Character.isDigit('a')); // 判断是不是数字
System.out.println(Character.isLetter('a')); // 判断是不是字母
System.out.println(Character.isUpperCase('a')); // 判断是不是大写
System.out.println(Character.isLowerCase('a')); // 判断是不是小写
System.out.println(Character.isWhitespace('a')); // 判断是不是空格
System.out.println(Character.toUpperCase('a')); // 转成大写
System.out.println(Character.toLowerCase('A')); // 转成小写
```

## 13.4 String 类

### 13.4.1 String 类的理解和创建对象

- String 对象用于保存字符串，也就是一组字符序列
- 字符串常量对象是用 **双引号** 括起的字符序列。例如："你好”、"12.97"、"boy" 等

- 字符串的字符使用 Unicode 字符编码，一个字符（不区分字母还是汉字）占两个字节。

- String 类较常用构造器（其它看手册）：

  ```java
  String s1 = new String();
  String s2 = new String(String original);
  String s3 = new String(char[] a);
  String s4 = new String(char[] a, int startIndex, int count);
  ```

### 13.4.2 创建String对象的两种方式

- 方式一：**直接赋值** `String s = "hspedu";`
- 方式二：**调用构造器** `String s = new String("hspedu");`

1. 方式一：先从常量池查看是否有 "`hsp`" 数据空间，如果有，直接指向；如果没有则重新创建，然后指向。`s` 最终指向的是常量池的空间地址；

2. 方式二：先在堆中创建空间，里面维护了 value 属性，指向常量池的 `hsp` 空间
   如果常量池没有 "`hsp`"，重新创建，如果有，直接通过 value 指向。最终指向的是堆中的空间地址；

3. 两种方式的内存分布图

   ![image-20220819193315460](.\img\image-20220819193315460.png)

